var ln=Object.defineProperty;var dn=(e,t,i)=>t in e?ln(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i;var Je=(e,t,i)=>dn(e,typeof t!="symbol"?t+"":t,i);import{i as Lt,a as ge,c as xt,b as fn,d as tt,e as hn}from"./redux-BXkGT1VS.js";import{p as Ce,i as ct,a as ut,e as pn,b as bt,c as $t,d as gn,o as yn}from"./immer-Dh7Cefx8.js";import{t as mn,w as bn}from"./redux-thunk-ClJT1hhx.js";import{S as vn}from"./@standard-schema-DjkmAgHD.js";import{w as vt,c as Bt}from"./reselect-utOO-l3Z.js";import{b as Sn,u as wn,a as En,c as Rn,s as Ie}from"./react-redux-93KjfrYX.js";import{r as U}from"./react-CjgZUFtf.js";var In=typeof window<"u"&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(arguments.length!==0)return typeof arguments[0]=="object"?tt:tt.apply(null,arguments)},Pn=e=>e&&typeof e.match=="function";function ee(e,t){function i(...f){if(t){let p=t(...f);if(!p)throw new Error(Y(0));return{type:e,payload:p.payload,..."meta"in p&&{meta:p.meta},..."error"in p&&{error:p.error}}}return{type:e,payload:f[0]}}return i.toString=()=>`${e}`,i.type=e,i.match=f=>Lt(f)&&f.type===e,i}var Vt=class we extends Array{constructor(...t){super(...t),Object.setPrototypeOf(this,we.prototype)}static get[Symbol.species](){return we}concat(...t){return super.concat.apply(this,t)}prepend(...t){return t.length===1&&Array.isArray(t[0])?new we(...t[0].concat(this)):new we(...t.concat(this))}};function St(e){return ct(e)?Ce(e,()=>{}):e}function Oe(e,t,i){return e.has(t)?e.get(t):e.set(t,i(t)).get(t)}function Mn(e){return typeof e=="boolean"}var An=()=>function(t){const{thunk:i=!0,immutableCheck:f=!0,serializableCheck:p=!0,actionCreatorCheck:b=!0}=t??{};let y=new Vt;return i&&(Mn(i)?y.push(mn):y.push(bn(i.extraArgument))),y},Fe="RTK_autoBatch",be=()=>e=>({payload:e,meta:{[Fe]:!0}}),wt=e=>t=>{setTimeout(t,e)},Cn=(e={type:"raf"})=>t=>(...i)=>{const f=t(...i);let p=!0,b=!1,y=!1;const M=new Set,R=e.type==="tick"?queueMicrotask:e.type==="raf"?typeof window<"u"&&window.requestAnimationFrame?window.requestAnimationFrame:wt(10):e.type==="callback"?e.queueNotification:wt(e.timeout),v=()=>{y=!1,b&&(b=!1,M.forEach(S=>S()))};return Object.assign({},f,{subscribe(S){const E=()=>p&&S(),Q=f.subscribe(E);return M.add(S),()=>{Q(),M.delete(S)}},dispatch(S){var E;try{return p=!((E=S==null?void 0:S.meta)!=null&&E[Fe]),b=!p,b&&(y||(y=!0,R(v))),f.dispatch(S)}finally{p=!0}}})},Qn=e=>function(i){const{autoBatch:f=!0}=i??{};let p=new Vt(e);return f&&p.push(Cn(typeof f=="object"?f:void 0)),p};function $r(e){const t=An(),{reducer:i=void 0,middleware:f,devTools:p=!0,preloadedState:b=void 0,enhancers:y=void 0}=e||{};let M;if(typeof i=="function")M=i;else if(ge(i))M=xt(i);else throw new Error(Y(1));let R;typeof f=="function"?R=f(t):R=t();let v=tt;p&&(v=In({trace:!1,...typeof p=="object"&&p}));const S=fn(...R),E=Qn(S);let Q=typeof y=="function"?y(E):E();const I=v(...Q);return hn(M,b,I)}function Ht(e){const t={},i=[];let f;const p={addCase(b,y){const M=typeof b=="string"?b:b.type;if(!M)throw new Error(Y(28));if(M in t)throw new Error(Y(29));return t[M]=y,p},addAsyncThunk(b,y){return y.pending&&(t[b.pending.type]=y.pending),y.rejected&&(t[b.rejected.type]=y.rejected),y.fulfilled&&(t[b.fulfilled.type]=y.fulfilled),y.settled&&i.push({matcher:b.settled,reducer:y.settled}),p},addMatcher(b,y){return i.push({matcher:b,reducer:y}),p},addDefaultCase(b){return f=b,p}};return e(p),[t,i,f]}function Tn(e){return typeof e=="function"}function On(e,t){let[i,f,p]=Ht(t),b;if(Tn(e))b=()=>St(e());else{const M=St(e);b=()=>M}function y(M=b(),R){let v=[i[R.type],...f.filter(({matcher:S})=>S(R)).map(({reducer:S})=>S)];return v.filter(S=>!!S).length===0&&(v=[p]),v.reduce((S,E)=>{if(E)if(ut(S)){const I=E(S,R);return I===void 0?S:I}else{if(ct(S))return Ce(S,Q=>E(Q,R));{const Q=E(S,R);if(Q===void 0){if(S===null)return S;throw Error("A case reducer on a non-draftable value must not return undefined")}return Q}}return S},M)}return y.getInitialState=b,y}var zt=(e,t)=>Pn(e)?e.match(t):e(t);function ne(...e){return t=>e.some(i=>zt(i,t))}function Pe(...e){return t=>e.every(i=>zt(i,t))}function Le(e,t){if(!e||!e.meta)return!1;const i=typeof e.meta.requestId=="string",f=t.indexOf(e.meta.requestStatus)>-1;return i&&f}function Qe(e){return typeof e[0]=="function"&&"pending"in e[0]&&"fulfilled"in e[0]&&"rejected"in e[0]}function lt(...e){return e.length===0?t=>Le(t,["pending"]):Qe(e)?ne(...e.map(t=>t.pending)):lt()(e[0])}function ye(...e){return e.length===0?t=>Le(t,["rejected"]):Qe(e)?ne(...e.map(t=>t.rejected)):ye()(e[0])}function xe(...e){const t=i=>i&&i.meta&&i.meta.rejectedWithValue;return e.length===0?Pe(ye(...e),t):Qe(e)?Pe(ye(...e),t):xe()(e[0])}function oe(...e){return e.length===0?t=>Le(t,["fulfilled"]):Qe(e)?ne(...e.map(t=>t.fulfilled)):oe()(e[0])}function nt(...e){return e.length===0?t=>Le(t,["pending","fulfilled","rejected"]):Qe(e)?ne(...e.flatMap(t=>[t.pending,t.rejected,t.fulfilled])):nt()(e[0])}var qn="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",dt=(e=21)=>{let t="",i=e;for(;i--;)t+=qn[Math.random()*64|0];return t},Dn=["name","message","stack","code"],Ge=class{constructor(e,t){Je(this,"_type");this.payload=e,this.meta=t}},Et=class{constructor(e,t){Je(this,"_type");this.payload=e,this.meta=t}},kn=e=>{if(typeof e=="object"&&e!==null){const t={};for(const i of Dn)typeof e[i]=="string"&&(t[i]=e[i]);return t}return{message:String(e)}},Rt="External signal was aborted",It=(()=>{function e(t,i,f){const p=ee(t+"/fulfilled",(R,v,S,E)=>({payload:R,meta:{...E||{},arg:S,requestId:v,requestStatus:"fulfilled"}})),b=ee(t+"/pending",(R,v,S)=>({payload:void 0,meta:{...S||{},arg:v,requestId:R,requestStatus:"pending"}})),y=ee(t+"/rejected",(R,v,S,E,Q)=>({payload:E,error:(f&&f.serializeError||kn)(R||"Rejected"),meta:{...Q||{},arg:S,requestId:v,rejectedWithValue:!!E,requestStatus:"rejected",aborted:(R==null?void 0:R.name)==="AbortError",condition:(R==null?void 0:R.name)==="ConditionError"}}));function M(R,{signal:v}={}){return(S,E,Q)=>{const I=f!=null&&f.idGenerator?f.idGenerator(R):dt(),k=new AbortController;let T,w;function A(m){w=m,k.abort()}v&&(v.aborted?A(Rt):v.addEventListener("abort",()=>A(Rt),{once:!0}));const O=(async function(){var o,h;let m;try{let l=(o=f==null?void 0:f.condition)==null?void 0:o.call(f,R,{getState:E,extra:Q});if(jn(l)&&(l=await l),l===!1||k.signal.aborted)throw{name:"ConditionError",message:"Aborted due to condition callback returning false."};const g=new Promise((a,s)=>{T=()=>{s({name:"AbortError",message:w||"Aborted"})},k.signal.addEventListener("abort",T)});S(b(I,R,(h=f==null?void 0:f.getPendingMeta)==null?void 0:h.call(f,{requestId:I,arg:R},{getState:E,extra:Q}))),m=await Promise.race([g,Promise.resolve(i(R,{dispatch:S,getState:E,extra:Q,requestId:I,signal:k.signal,abort:A,rejectWithValue:(a,s)=>new Ge(a,s),fulfillWithValue:(a,s)=>new Et(a,s)})).then(a=>{if(a instanceof Ge)throw a;return a instanceof Et?p(a.payload,I,R,a.meta):p(a,I,R)})])}catch(l){m=l instanceof Ge?y(null,I,R,l.payload,l.meta):y(l,I,R)}finally{T&&k.signal.removeEventListener("abort",T)}return f&&!f.dispatchConditionRejection&&y.match(m)&&m.meta.condition||S(m),m})();return Object.assign(O,{abort:A,requestId:I,arg:R,unwrap(){return O.then(Nn)}})}}return Object.assign(M,{pending:b,rejected:y,fulfilled:p,settled:ne(y,p),typePrefix:t})}return e.withTypes=()=>e,e})();function Nn(e){if(e.meta&&e.meta.rejectedWithValue)throw e.payload;if(e.error)throw e.error;return e.payload}function jn(e){return e!==null&&typeof e=="object"&&typeof e.then=="function"}var _n=Symbol.for("rtk-slice-createasyncthunk");function Un(e,t){return`${e}/${t}`}function Fn({creators:e}={}){var i;const t=(i=e==null?void 0:e.asyncThunk)==null?void 0:i[_n];return function(p){const{name:b,reducerPath:y=b}=p;if(!b)throw new Error(Y(11));const M=(typeof p.reducers=="function"?p.reducers(xn()):p.reducers)||{},R=Object.keys(M),v={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},S={addCase(u,o){const h=typeof u=="string"?u:u.type;if(!h)throw new Error(Y(12));if(h in v.sliceCaseReducersByType)throw new Error(Y(13));return v.sliceCaseReducersByType[h]=o,S},addMatcher(u,o){return v.sliceMatchers.push({matcher:u,reducer:o}),S},exposeAction(u,o){return v.actionCreators[u]=o,S},exposeCaseReducer(u,o){return v.sliceCaseReducersByName[u]=o,S}};R.forEach(u=>{const o=M[u],h={reducerName:u,type:Un(b,u),createNotation:typeof p.reducers=="function"};Bn(o)?Hn(h,o,S,t):$n(h,o,S)});function E(){const[u={},o=[],h=void 0]=typeof p.extraReducers=="function"?Ht(p.extraReducers):[p.extraReducers],l={...u,...v.sliceCaseReducersByType};return On(p.initialState,g=>{for(let a in l)g.addCase(a,l[a]);for(let a of v.sliceMatchers)g.addMatcher(a.matcher,a.reducer);for(let a of o)g.addMatcher(a.matcher,a.reducer);h&&g.addDefaultCase(h)})}const Q=u=>u,I=new Map,k=new WeakMap;let T;function w(u,o){return T||(T=E()),T(u,o)}function A(){return T||(T=E()),T.getInitialState()}function O(u,o=!1){function h(g){let a=g[u];return typeof a>"u"&&o&&(a=Oe(k,h,A)),a}function l(g=Q){const a=Oe(I,o,()=>new WeakMap);return Oe(a,g,()=>{const s={};for(const[n,r]of Object.entries(p.selectors??{}))s[n]=Ln(r,g,()=>Oe(k,g,A),o);return s})}return{reducerPath:u,getSelectors:l,get selectors(){return l(h)},selectSlice:h}}const m={name:b,reducer:w,actions:v.actionCreators,caseReducers:v.sliceCaseReducersByName,getInitialState:A,...O(y),injectInto(u,{reducerPath:o,...h}={}){const l=o??y;return u.inject({reducerPath:l,reducer:w},h),{...m,...O(l,!0)}}};return m}}function Ln(e,t,i,f){function p(b,...y){let M=t(b);return typeof M>"u"&&f&&(M=i()),e(M,...y)}return p.unwrapped=e,p}var fe=Fn();function xn(){function e(t,i){return{_reducerDefinitionType:"asyncThunk",payloadCreator:t,...i}}return e.withTypes=()=>e,{reducer(t){return Object.assign({[t.name](...i){return t(...i)}}[t.name],{_reducerDefinitionType:"reducer"})},preparedReducer(t,i){return{_reducerDefinitionType:"reducerWithPrepare",prepare:t,reducer:i}},asyncThunk:e}}function $n({type:e,reducerName:t,createNotation:i},f,p){let b,y;if("reducer"in f){if(i&&!Vn(f))throw new Error(Y(17));b=f.reducer,y=f.prepare}else b=f;p.addCase(e,b).exposeCaseReducer(t,b).exposeAction(t,y?ee(e,y):ee(e))}function Bn(e){return e._reducerDefinitionType==="asyncThunk"}function Vn(e){return e._reducerDefinitionType==="reducerWithPrepare"}function Hn({type:e,reducerName:t},i,f,p){if(!p)throw new Error(Y(18));const{payloadCreator:b,fulfilled:y,pending:M,rejected:R,settled:v,options:S}=i,E=p(e,b,S);f.exposeAction(t,E),y&&f.addCase(E.fulfilled,y),M&&f.addCase(E.pending,M),R&&f.addCase(E.rejected,R),v&&f.addMatcher(E.settled,v),f.exposeCaseReducer(t,{fulfilled:y||qe,pending:M||qe,rejected:R||qe,settled:v||qe})}function qe(){}function Y(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}var Kt=(e=>(e.uninitialized="uninitialized",e.pending="pending",e.fulfilled="fulfilled",e.rejected="rejected",e))(Kt||{}),re="uninitialized",rt="pending",Ee="fulfilled",Re="rejected";function Pt(e){return{status:e,isUninitialized:e===re,isLoading:e===rt,isSuccess:e===Ee,isError:e===Re}}var Mt=ge;function ft(e,t){if(e===t||!(Mt(e)&&Mt(t)||Array.isArray(e)&&Array.isArray(t)))return t;const i=Object.keys(t),f=Object.keys(e);let p=i.length===f.length;const b=Array.isArray(t)?[]:{};for(const y of i)b[y]=ft(e[y],t[y]),p&&(p=e[y]===b[y]);return p?e:b}function it(e,t,i){return e.reduce((f,p,b)=>(t(p,b)&&f.push(i(p,b)),f),[]).flat()}function zn(e){return new RegExp("(^|:)//").test(e)}function Kn(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function ht(e){return e!=null}function At(e){return[...(e==null?void 0:e.values())??[]].filter(ht)}function Wn(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var Jn=e=>e.replace(/\/$/,""),Gn=e=>e.replace(/^\//,"");function Yn(e,t){if(!e)return t;if(!t)return e;if(zn(t))return t;const i=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=Jn(e),t=Gn(t),`${e}${i}${t}`}function _e(e,t,i){return e.has(t)?e.get(t):e.set(t,i(t)).get(t)}var st=()=>new Map,Ct=(...e)=>fetch(...e),Xn=e=>e.status>=200&&e.status<=299,Zn=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function Qt(e){if(!ge(e))return e;const t={...e};for(const[i,f]of Object.entries(t))f===void 0&&delete t[i];return t}var er=e=>typeof e=="object"&&(ge(e)||Array.isArray(e)||typeof e.toJSON=="function");function Br({baseUrl:e,prepareHeaders:t=E=>E,fetchFn:i=Ct,paramsSerializer:f,isJsonContentType:p=Zn,jsonContentType:b="application/json",jsonReplacer:y,timeout:M,responseHandler:R,validateStatus:v,...S}={}){return typeof fetch>"u"&&i===Ct&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(Q,I,k)=>{const{getState:T,extra:w,endpoint:A,forced:O,type:m}=I;let u,{url:o,headers:h=new Headers(S.headers),params:l=void 0,responseHandler:g=R??"json",validateStatus:a=v??Xn,timeout:s=M,...n}=typeof Q=="string"?{url:Q}:Q,r,d=I.signal;s&&(r=new AbortController,I.signal.addEventListener("abort",r.abort),d=r.signal);let c={...S,signal:d,...n};h=new Headers(Qt(h)),c.headers=await t(h,{getState:T,arg:Q,extra:w,endpoint:A,forced:O,type:m,extraOptions:k})||h;const P=er(c.body);if(c.body!=null&&!P&&typeof c.body!="string"&&c.headers.delete("content-type"),!c.headers.has("content-type")&&P&&c.headers.set("content-type",b),P&&p(c.headers)&&(c.body=JSON.stringify(c.body,y)),c.headers.has("accept")||(g==="json"?c.headers.set("accept","application/json"):g==="text"&&c.headers.set("accept","text/plain, text/html, */*")),l){const L=~o.indexOf("?")?"&":"?",z=f?f(l):new URLSearchParams(Qt(l));o+=L+z}o=Yn(e,o);const D=new Request(o,c);u={request:new Request(o,c)};let q,C=!1,_=r&&setTimeout(()=>{C=!0,r.abort()},s);try{q=await i(D)}catch(L){return{error:{status:C?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(L)},meta:u}}finally{_&&clearTimeout(_),r==null||r.signal.removeEventListener("abort",r.abort)}const j=q.clone();u.response=j;let $,V="";try{let L;if(await Promise.all([E(q,g).then(z=>$=z,z=>L=z),j.text().then(z=>V=z,()=>{})]),L)throw L}catch(L){return{error:{status:"PARSING_ERROR",originalStatus:q.status,data:V,error:String(L)},meta:u}}return a(q,$)?{data:$,meta:u}:{error:{status:q.status,data:$},meta:u}};async function E(Q,I){if(typeof I=="function")return I(Q);if(I==="content-type"&&(I=p(Q.headers)?"json":"text"),I==="json"){const k=await Q.text();return k.length?JSON.parse(k):null}return Q.text()}}var Tt=class{constructor(e,t=void 0){this.value=e,this.meta=t}},$e="__rtkq/",Wt="online",Jt="offline",tr="focus",Gt="focused",nr="visibilitychange",Be=ee(`${$e}${Gt}`),pt=ee(`${$e}un${Gt}`),Ve=ee(`${$e}${Wt}`),gt=ee(`${$e}${Jt}`),De=!1;function Vr(e,t){function i(){const[f,p,b,y]=[Be,pt,Ve,gt].map(v=>()=>e(v())),M=()=>{window.document.visibilityState==="visible"?f():p()};let R=()=>{De=!1};if(!De&&typeof window<"u"&&window.addEventListener){let v=function(E){Object.entries(S).forEach(([Q,I])=>{E?window.addEventListener(Q,I,!1):window.removeEventListener(Q,I)})};const S={[tr]:f,[nr]:M,[Wt]:b,[Jt]:y};v(!0),De=!0,R=()=>{v(!1),De=!1}}return R}return i()}var Te="query",Yt="mutation",Xt="infinitequery";function He(e){return e.type===Te}function rr(e){return e.type===Yt}function ze(e){return e.type===Xt}function Ue(e){return He(e)||ze(e)}function yt(e,t,i,f,p,b){const y=ir(e)?e(t,i,f,p):e;return y?it(y,ht,M=>b(Zt(M))):[]}function ir(e){return typeof e=="function"}function Zt(e){return typeof e=="string"?{type:e}:e}function sr(e,t){return e.catch(t)}var me=(e,t)=>e.endpointDefinitions[t],Me=Symbol("forceQueryFn"),ot=e=>typeof e[Me]=="function";function or({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:i,mutationThunk:f,api:p,context:b,getInternalState:y}){const M=u=>{var o;return(o=y(u))==null?void 0:o.runningQueries},R=u=>{var o;return(o=y(u))==null?void 0:o.runningMutations},{unsubscribeQueryResult:v,removeMutationResult:S,updateSubscriptionOptions:E}=p.internalActions;return{buildInitiateQuery:A,buildInitiateInfiniteQuery:O,buildInitiateMutation:m,getRunningQueryThunk:Q,getRunningMutationThunk:I,getRunningQueriesThunk:k,getRunningMutationsThunk:T};function Q(u,o){return h=>{var a;const l=me(b,u),g=e({queryArgs:o,endpointDefinition:l,endpointName:u});return(a=M(h))==null?void 0:a.get(g)}}function I(u,o){return h=>{var l;return(l=R(h))==null?void 0:l.get(o)}}function k(){return u=>At(M(u))}function T(){return u=>At(R(u))}function w(u,o){const h=(l,{subscribe:g=!0,forceRefetch:a,subscriptionOptions:s,[Me]:n,...r}={})=>(d,c)=>{var x;const P=e({queryArgs:l,endpointDefinition:o,endpointName:u});let D;const N={...r,type:Te,subscribe:g,forceRefetch:a,subscriptionOptions:s,endpointName:u,originalArgs:l,queryCacheKey:P,[Me]:n};if(He(o))D=t(N);else{const{direction:F,initialPageParam:W,refetchCachedPages:J}=r;D=i({...N,direction:F,initialPageParam:W,refetchCachedPages:J})}const q=p.endpoints[u].select(l),C=d(D),_=q(c()),{requestId:j,abort:$}=C,V=_.requestId!==j,L=(x=M(d))==null?void 0:x.get(P),z=()=>q(c()),K=Object.assign(n?C.then(z):V&&!L?Promise.resolve(_):Promise.all([L,C]).then(z),{arg:l,requestId:j,subscriptionOptions:s,queryCacheKey:P,abort:$,async unwrap(){const F=await K;if(F.isError)throw F.error;return F.data},refetch:F=>d(h(l,{subscribe:!1,forceRefetch:!0,...F})),unsubscribe(){g&&d(v({queryCacheKey:P,requestId:j}))},updateSubscriptionOptions(F){K.subscriptionOptions=F,d(E({endpointName:u,requestId:j,queryCacheKey:P,options:F}))}});if(!L&&!V&&!n){const F=M(d);F.set(P,K),K.then(()=>{F.delete(P)})}return K};return h}function A(u,o){return w(u,o)}function O(u,o){return w(u,o)}function m(u){return(o,{track:h=!0,fixedCacheKey:l}={})=>(g,a)=>{const s=f({type:"mutation",endpointName:u,originalArgs:o,track:h,fixedCacheKey:l}),n=g(s),{requestId:r,abort:d,unwrap:c}=n,P=sr(n.unwrap().then(C=>({data:C})),C=>({error:C})),D=()=>{g(S({requestId:r,fixedCacheKey:l}))},N=Object.assign(P,{arg:n.arg,requestId:r,abort:d,unwrap:c,reset:D}),q=R(g);return q.set(r,N),N.then(()=>{q.delete(r)}),l&&(q.set(l,N),N.then(()=>{q.get(l)===N&&q.delete(l)})),N}}}var en=class extends vn{constructor(e,t,i,f){super(e),this.value=t,this.schemaName=i,this._bqMeta=f}},ae=(e,t)=>Array.isArray(e)?e.includes(t):!!e;async function ce(e,t,i,f){const p=await e["~standard"].validate(t);if(p.issues)throw new en(p.issues,t,i,f);return p.value}function Ot(e){return e}var ve=(e={})=>({...e,[Fe]:!0});function ar({reducerPath:e,baseQuery:t,context:{endpointDefinitions:i},serializeQueryArgs:f,api:p,assertTagType:b,selectors:y,onSchemaFailure:M,catchSchemaFailure:R,skipSchemaValidation:v}){const S=(n,r,d,c)=>(P,D)=>{const N=i[n],q=f({queryArgs:r,endpointDefinition:N,endpointName:n});if(P(p.internalActions.queryResultPatched({queryCacheKey:q,patches:d})),!c)return;const C=p.endpoints[n].select(r)(D()),_=yt(N.providesTags,C.data,void 0,r,{},b);P(p.internalActions.updateProvidedBy([{queryCacheKey:q,providedTags:_}]))};function E(n,r,d=0){const c=[r,...n];return d&&c.length>d?c.slice(0,-1):c}function Q(n,r,d=0){const c=[...n,r];return d&&c.length>d?c.slice(1):c}const I=(n,r,d,c=!0)=>(P,D)=>{const q=p.endpoints[n].select(r)(D()),C={patches:[],inversePatches:[],undo:()=>P(p.util.patchQueryData(n,r,C.inversePatches,c))};if(q.status===re)return C;let _;if("data"in q)if(ct(q.data)){const[j,$,V]=$t(q.data,d);C.patches.push(...$),C.inversePatches.push(...V),_=j}else _=d(q.data),C.patches.push({op:"replace",path:[],value:_}),C.inversePatches.push({op:"replace",path:[],value:q.data});return C.patches.length===0||P(p.util.patchQueryData(n,r,C.patches,c)),C},k=(n,r,d)=>c=>c(p.endpoints[n].initiate(r,{subscribe:!1,forceRefetch:!0,[Me]:()=>({data:d})})),T=(n,r)=>n.query&&n[r]?n[r]:Ot,w=async(n,{signal:r,abort:d,rejectWithValue:c,fulfillWithValue:P,dispatch:D,getState:N,extra:q})=>{var V,L;const C=i[n.endpointName],{metaSchema:_,skipSchemaValidation:j=v}=C,$=n.type===Te;try{let z=Ot;const K={signal:r,abort:d,dispatch:D,getState:N,extra:q,endpoint:n.endpointName,type:n.type,forced:$?A(n,N()):void 0,queryCacheKey:$?n.queryCacheKey:void 0},x=$?n[Me]:void 0;let F;const W=async(B,H,ie,G)=>{if(H==null&&B.pages.length)return Promise.resolve({data:B});const ue={queryArg:n.originalArgs,pageParam:H},X=await J(ue),le=G?E:Q;return{data:{pages:le(B.pages,X.data,ie),pageParams:le(B.pageParams,H,ie)},meta:X.meta}};async function J(B){let H;const{extraOptions:ie,argSchema:G,rawResponseSchema:ue,responseSchema:X}=C;if(G&&!ae(j,"arg")&&(B=await ce(G,B,"argSchema",{})),x?H=x():C.query?(z=T(C,"transformResponse"),H=await t(C.query(B),K,ie)):H=await C.queryFn(B,K,ie,de=>t(de,K,ie)),typeof process<"u",H.error)throw new Tt(H.error,H.meta);let{data:le}=H;ue&&!ae(j,"rawResponse")&&(le=await ce(ue,H.data,"rawResponseSchema",H.meta));let se=await z(le,H.meta,B);return X&&!ae(j,"response")&&(se=await ce(X,se,"responseSchema",H.meta)),{...H,data:se}}if($&&"infiniteQueryOptions"in C){const{infiniteQueryOptions:B}=C,{maxPages:H=1/0}=B,ie=n.refetchCachedPages??B.refetchCachedPages??!0;let G;const ue={pages:[],pageParams:[]},X=(V=y.selectQueryEntry(N(),n.queryCacheKey))==null?void 0:V.data,se=A(n,N())&&!n.direction||!X?ue:X;if("direction"in n&&n.direction&&se.pages.length){const de=n.direction==="backward",We=(de?tn:at)(B,se,n.originalArgs);G=await W(se,We,H,de)}else{const{initialPageParam:de=B.initialPageParam}=n,Ke=(X==null?void 0:X.pageParams)??[],We=Ke[0]??de,cn=Ke.length;if(G=await W(se,We,H),x&&(G={data:G.data.pages[0]}),ie)for(let mt=1;mt<cn;mt++){const un=at(B,G.data,n.originalArgs);G=await W(G.data,un,H)}}F=G}else F=await J(n.originalArgs);return _&&!ae(j,"meta")&&F.meta&&(F.meta=await ce(_,F.meta,"metaSchema",F.meta)),P(F.data,ve({fulfilledTimeStamp:Date.now(),baseQueryMeta:F.meta}))}catch(z){let K=z;if(K instanceof Tt){let x=T(C,"transformErrorResponse");const{rawErrorResponseSchema:F,errorResponseSchema:W}=C;let{value:J,meta:B}=K;try{F&&!ae(j,"rawErrorResponse")&&(J=await ce(F,J,"rawErrorResponseSchema",B)),_&&!ae(j,"meta")&&(B=await ce(_,B,"metaSchema",B));let H=await x(J,B,n.originalArgs);return W&&!ae(j,"errorResponse")&&(H=await ce(W,H,"errorResponseSchema",B)),c(H,ve({baseQueryMeta:B}))}catch(H){K=H}}try{if(K instanceof en){const x={endpoint:n.endpointName,arg:n.originalArgs,type:n.type,queryCacheKey:$?n.queryCacheKey:void 0};(L=C.onSchemaFailure)==null||L.call(C,K,x),M==null||M(K,x);const{catchSchemaFailure:F=R}=C;if(F)return c(F(K,x),ve({baseQueryMeta:K._bqMeta}))}}catch(x){K=x}throw console.error(K),K}};function A(n,r){const d=y.selectQueryEntry(r,n.queryCacheKey),c=y.selectConfig(r).refetchOnMountOrArgChange,P=d==null?void 0:d.fulfilledTimeStamp,D=n.forceRefetch??(n.subscribe&&c);return D?D===!0||(Number(new Date)-Number(P))/1e3>=D:!1}const O=()=>It(`${e}/executeQuery`,w,{getPendingMeta({arg:r}){const d=i[r.endpointName];return ve({startedTimeStamp:Date.now(),...ze(d)?{direction:r.direction}:{}})},condition(r,{getState:d}){var j;const c=d(),P=y.selectQueryEntry(c,r.queryCacheKey),D=P==null?void 0:P.fulfilledTimeStamp,N=r.originalArgs,q=P==null?void 0:P.originalArgs,C=i[r.endpointName],_=r.direction;return ot(r)?!0:(P==null?void 0:P.status)==="pending"?!1:A(r,c)||He(C)&&((j=C==null?void 0:C.forceRefetch)!=null&&j.call(C,{currentArg:N,previousArg:q,endpointState:P,state:c}))?!0:!(D&&!_)},dispatchConditionRejection:!0}),m=O(),u=O(),o=It(`${e}/executeMutation`,w,{getPendingMeta(){return ve({startedTimeStamp:Date.now()})}}),h=n=>"force"in n,l=n=>"ifOlderThan"in n,g=(n,r,d={})=>(c,P)=>{const D=h(d)&&d.force,N=l(d)&&d.ifOlderThan,q=(_=!0)=>{const j={forceRefetch:_,subscribe:!1};return p.endpoints[n].initiate(r,j)},C=p.endpoints[n].select(r)(P());if(D)c(q());else if(N){const _=C==null?void 0:C.fulfilledTimeStamp;if(!_){c(q());return}(Number(new Date)-Number(new Date(_)))/1e3>=N&&c(q())}else c(q(!1))};function a(n){return r=>{var d,c;return((c=(d=r==null?void 0:r.meta)==null?void 0:d.arg)==null?void 0:c.endpointName)===n}}function s(n,r){return{matchPending:Pe(lt(n),a(r)),matchFulfilled:Pe(oe(n),a(r)),matchRejected:Pe(ye(n),a(r))}}return{queryThunk:m,mutationThunk:o,infiniteQueryThunk:u,prefetch:g,updateQueryData:I,upsertQueryData:k,patchQueryData:S,buildMatchThunkActions:s}}function at(e,{pages:t,pageParams:i},f){const p=t.length-1;return e.getNextPageParam(t[p],t,i[p],i,f)}function tn(e,{pages:t,pageParams:i},f){var p;return(p=e.getPreviousPageParam)==null?void 0:p.call(e,t[0],t,i[0],i,f)}function nn(e,t,i,f){return yt(i[e.meta.arg.endpointName][t],oe(e)?e.payload:void 0,xe(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,f)}function qt(e){return ut(e)?gn(e):e}function ke(e,t,i){const f=e[t];f&&i(f)}function Ae(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function Dt(e,t,i){const f=e[Ae(t)];f&&i(f)}var Ne={};function cr({reducerPath:e,queryThunk:t,mutationThunk:i,serializeQueryArgs:f,context:{endpointDefinitions:p,apiUid:b,extractRehydrationInfo:y,hasRehydrationInfo:M},assertTagType:R,config:v}){const S=ee(`${e}/resetApiState`);function E(a,s,n,r){var d;a[d=s.queryCacheKey]??(a[d]={status:re,endpointName:s.endpointName}),ke(a,s.queryCacheKey,c=>{c.status=rt,c.requestId=n&&c.requestId?c.requestId:r.requestId,s.originalArgs!==void 0&&(c.originalArgs=s.originalArgs),c.startedTimeStamp=r.startedTimeStamp;const P=p[r.arg.endpointName];ze(P)&&"direction"in s&&(c.direction=s.direction)})}function Q(a,s,n,r){ke(a,s.arg.queryCacheKey,d=>{if(d.requestId!==s.requestId&&!r)return;const{merge:c}=p[s.arg.endpointName];if(d.status=Ee,c)if(d.data!==void 0){const{fulfilledTimeStamp:P,arg:D,baseQueryMeta:N,requestId:q}=s;let C=Ce(d.data,_=>c(_,n,{arg:D.originalArgs,baseQueryMeta:N,fulfilledTimeStamp:P,requestId:q}));d.data=C}else d.data=n;else d.data=p[s.arg.endpointName].structuralSharing??!0?ft(ut(d.data)?yn(d.data):d.data,n):n;delete d.error,d.fulfilledTimeStamp=s.fulfilledTimeStamp})}const I=fe({name:`${e}/queries`,initialState:Ne,reducers:{removeQueryResult:{reducer(a,{payload:{queryCacheKey:s}}){delete a[s]},prepare:be()},cacheEntriesUpserted:{reducer(a,s){for(const n of s.payload){const{queryDescription:r,value:d}=n;E(a,r,!0,{arg:r,requestId:s.meta.requestId,startedTimeStamp:s.meta.timestamp}),Q(a,{arg:r,requestId:s.meta.requestId,fulfilledTimeStamp:s.meta.timestamp,baseQueryMeta:{}},d,!0)}},prepare:a=>({payload:a.map(r=>{const{endpointName:d,arg:c,value:P}=r,D=p[d];return{queryDescription:{type:Te,endpointName:d,originalArgs:r.arg,queryCacheKey:f({queryArgs:c,endpointDefinition:D,endpointName:d})},value:P}}),meta:{[Fe]:!0,requestId:dt(),timestamp:Date.now()}})},queryResultPatched:{reducer(a,{payload:{queryCacheKey:s,patches:n}}){ke(a,s,r=>{r.data=bt(r.data,n.concat())})},prepare:be()}},extraReducers(a){a.addCase(t.pending,(s,{meta:n,meta:{arg:r}})=>{const d=ot(r);E(s,r,d,n)}).addCase(t.fulfilled,(s,{meta:n,payload:r})=>{const d=ot(n.arg);Q(s,n,r,d)}).addCase(t.rejected,(s,{meta:{condition:n,arg:r,requestId:d},error:c,payload:P})=>{ke(s,r.queryCacheKey,D=>{if(!n){if(D.requestId!==d)return;D.status=Re,D.error=P??c}})}).addMatcher(M,(s,n)=>{const{queries:r}=y(n);for(const[d,c]of Object.entries(r))((c==null?void 0:c.status)===Ee||(c==null?void 0:c.status)===Re)&&(s[d]=c)})}}),k=fe({name:`${e}/mutations`,initialState:Ne,reducers:{removeMutationResult:{reducer(a,{payload:s}){const n=Ae(s);n in a&&delete a[n]},prepare:be()}},extraReducers(a){a.addCase(i.pending,(s,{meta:n,meta:{requestId:r,arg:d,startedTimeStamp:c}})=>{d.track&&(s[Ae(n)]={requestId:r,status:rt,endpointName:d.endpointName,startedTimeStamp:c})}).addCase(i.fulfilled,(s,{payload:n,meta:r})=>{r.arg.track&&Dt(s,r,d=>{d.requestId===r.requestId&&(d.status=Ee,d.data=n,d.fulfilledTimeStamp=r.fulfilledTimeStamp)})}).addCase(i.rejected,(s,{payload:n,error:r,meta:d})=>{d.arg.track&&Dt(s,d,c=>{c.requestId===d.requestId&&(c.status=Re,c.error=n??r)})}).addMatcher(M,(s,n)=>{const{mutations:r}=y(n);for(const[d,c]of Object.entries(r))((c==null?void 0:c.status)===Ee||(c==null?void 0:c.status)===Re)&&d!==(c==null?void 0:c.requestId)&&(s[d]=c)})}}),T={tags:{},keys:{}},w=fe({name:`${e}/invalidation`,initialState:T,reducers:{updateProvidedBy:{reducer(a,s){var n,r,d;for(const{queryCacheKey:c,providedTags:P}of s.payload){A(a,c);for(const{type:D,id:N}of P){const q=(r=(n=a.tags)[D]??(n[D]={}))[d=N||"__internal_without_id"]??(r[d]=[]);q.includes(c)||q.push(c)}a.keys[c]=P}},prepare:be()}},extraReducers(a){a.addCase(I.actions.removeQueryResult,(s,{payload:{queryCacheKey:n}})=>{A(s,n)}).addMatcher(M,(s,n)=>{var d,c,P;const{provided:r}=y(n);for(const[D,N]of Object.entries(r.tags??{}))for(const[q,C]of Object.entries(N)){const _=(c=(d=s.tags)[D]??(d[D]={}))[P=q||"__internal_without_id"]??(c[P]=[]);for(const j of C)_.includes(j)||_.push(j),s.keys[j]=r.keys[j]}}).addMatcher(ne(oe(t),xe(t)),(s,n)=>{O(s,[n])}).addMatcher(I.actions.cacheEntriesUpserted.match,(s,n)=>{const r=n.payload.map(({queryDescription:d,value:c})=>({type:"UNKNOWN",payload:c,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:d}}));O(s,r)})}});function A(a,s){var r;const n=qt(a.keys[s]??[]);for(const d of n){const c=d.type,P=d.id??"__internal_without_id",D=(r=a.tags[c])==null?void 0:r[P];D&&(a.tags[c][P]=qt(D).filter(N=>N!==s))}delete a.keys[s]}function O(a,s){const n=s.map(r=>{const d=nn(r,"providesTags",p,R),{queryCacheKey:c}=r.meta.arg;return{queryCacheKey:c,providedTags:d}});w.caseReducers.updateProvidedBy(a,w.actions.updateProvidedBy(n))}const m=fe({name:`${e}/subscriptions`,initialState:Ne,reducers:{updateSubscriptionOptions(a,s){},unsubscribeQueryResult(a,s){},internal_getRTKQSubscriptions(){}}}),u=fe({name:`${e}/internalSubscriptions`,initialState:Ne,reducers:{subscriptionsUpdated:{reducer(a,s){return bt(a,s.payload)},prepare:be()}}}),o=fe({name:`${e}/config`,initialState:{online:Wn(),focused:Kn(),middlewareRegistered:!1,...v},reducers:{middlewareRegistered(a,{payload:s}){a.middlewareRegistered=a.middlewareRegistered==="conflict"||b!==s?"conflict":!0}},extraReducers:a=>{a.addCase(Ve,s=>{s.online=!0}).addCase(gt,s=>{s.online=!1}).addCase(Be,s=>{s.focused=!0}).addCase(pt,s=>{s.focused=!1}).addMatcher(M,s=>({...s}))}}),h=xt({queries:I.reducer,mutations:k.reducer,provided:w.reducer,subscriptions:u.reducer,config:o.reducer}),l=(a,s)=>h(S.match(s)?void 0:a,s),g={...o.actions,...I.actions,...m.actions,...u.actions,...k.actions,...w.actions,resetApiState:S};return{reducer:l,actions:g}}var Z=Symbol.for("RTKQ/skipToken"),rn={status:re},kt=Ce(rn,()=>{}),Nt=Ce(rn,()=>{});function ur({serializeQueryArgs:e,reducerPath:t,createSelector:i}){const f=m=>kt,p=m=>Nt;return{buildQuerySelector:Q,buildInfiniteQuerySelector:I,buildMutationSelector:k,selectInvalidatedBy:T,selectCachedArgsForQuery:w,selectApiState:y,selectQueries:M,selectMutations:v,selectQueryEntry:R,selectConfig:S};function b(m){return{...m,...Pt(m.status)}}function y(m){return m[t]}function M(m){var u;return(u=y(m))==null?void 0:u.queries}function R(m,u){var o;return(o=M(m))==null?void 0:o[u]}function v(m){var u;return(u=y(m))==null?void 0:u.mutations}function S(m){var u;return(u=y(m))==null?void 0:u.config}function E(m,u,o){return h=>{if(h===Z)return i(f,o);const l=e({queryArgs:h,endpointDefinition:u,endpointName:m});return i(a=>R(a,l)??kt,o)}}function Q(m,u){return E(m,u,b)}function I(m,u){const{infiniteQueryOptions:o}=u;function h(l){const g={...l,...Pt(l.status)},{isLoading:a,isError:s,direction:n}=g,r=n==="forward",d=n==="backward";return{...g,hasNextPage:A(o,g.data,g.originalArgs),hasPreviousPage:O(o,g.data,g.originalArgs),isFetchingNextPage:a&&r,isFetchingPreviousPage:a&&d,isFetchNextPageError:s&&r,isFetchPreviousPageError:s&&d}}return E(m,u,h)}function k(){return m=>{let u;return typeof m=="object"?u=Ae(m)??Z:u=m,i(u===Z?p:l=>{var g,a;return((a=(g=y(l))==null?void 0:g.mutations)==null?void 0:a[u])??Nt},b)}}function T(m,u){const o=m[t],h=new Set,l=it(u,ht,Zt);for(const g of l){const a=o.provided.tags[g.type];if(!a)continue;let s=(g.id!==void 0?a[g.id]:Object.values(a).flat())??[];for(const n of s)h.add(n)}return Array.from(h.values()).flatMap(g=>{const a=o.queries[g];return a?{queryCacheKey:g,endpointName:a.endpointName,originalArgs:a.originalArgs}:[]})}function w(m,u){return it(Object.values(M(m)),o=>(o==null?void 0:o.endpointName)===u&&o.status!==re,o=>o.originalArgs)}function A(m,u,o){return u?at(m,u,o)!=null:!1}function O(m,u,o){return!u||!m.getPreviousPageParam?!1:tn(m,u,o)!=null}}var he=WeakMap?new WeakMap:void 0,jt=({endpointName:e,queryArgs:t})=>{let i="";const f=he==null?void 0:he.get(t);if(typeof f=="string")i=f;else{const p=JSON.stringify(t,(b,y)=>(y=typeof y=="bigint"?{$bigint:y.toString()}:y,y=ge(y)?Object.keys(y).sort().reduce((M,R)=>(M[R]=y[R],M),{}):y,y));ge(t)&&(he==null||he.set(t,p)),i=p}return`${e}(${i})`};function sn(...e){return function(i){const f=vt(v=>{var S;return(S=i.extractRehydrationInfo)==null?void 0:S.call(i,v,{reducerPath:i.reducerPath??"api"})}),p={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...i,extractRehydrationInfo:f,serializeQueryArgs(v){let S=jt;if("serializeQueryArgs"in v.endpointDefinition){const E=v.endpointDefinition.serializeQueryArgs;S=Q=>{const I=E(Q);return typeof I=="string"?I:jt({...Q,queryArgs:I})}}else i.serializeQueryArgs&&(S=i.serializeQueryArgs);return S(v)},tagTypes:[...i.tagTypes||[]]},b={endpointDefinitions:{},batch(v){v()},apiUid:dt(),extractRehydrationInfo:f,hasRehydrationInfo:vt(v=>f(v)!=null)},y={injectEndpoints:R,enhanceEndpoints({addTagTypes:v,endpoints:S}){if(v)for(const E of v)p.tagTypes.includes(E)||p.tagTypes.push(E);if(S)for(const[E,Q]of Object.entries(S))typeof Q=="function"?Q(me(b,E)):Object.assign(me(b,E)||{},Q);return y}},M=e.map(v=>v.init(y,p,b));function R(v){const S=v.endpoints({query:E=>({...E,type:Te}),mutation:E=>({...E,type:Yt}),infiniteQuery:E=>({...E,type:Xt})});for(const[E,Q]of Object.entries(S)){if(v.overrideExisting!==!0&&E in b.endpointDefinitions){if(v.overrideExisting==="throw")throw new Error(Y(39));continue}b.endpointDefinitions[E]=Q;for(const I of M)I.injectEndpoint(E,Q)}return y}return y.injectEndpoints({endpoints:i.endpoints})}}function te(e,...t){return Object.assign(e,...t)}var lr=({api:e,queryThunk:t,internalState:i,mwApi:f})=>{const p=`${e.reducerPath}/subscriptions`;let b=null,y=null;const{updateSubscriptionOptions:M,unsubscribeQueryResult:R}=e.internalActions,v=(T,w)=>{if(M.match(w)){const{queryCacheKey:O,requestId:m,options:u}=w.payload,o=T.get(O);return o!=null&&o.has(m)&&o.set(m,u),!0}if(R.match(w)){const{queryCacheKey:O,requestId:m}=w.payload,u=T.get(O);return u&&u.delete(m),!0}if(e.internalActions.removeQueryResult.match(w))return T.delete(w.payload.queryCacheKey),!0;if(t.pending.match(w)){const{meta:{arg:O,requestId:m}}=w,u=_e(T,O.queryCacheKey,st);return O.subscribe&&u.set(m,O.subscriptionOptions??u.get(m)??{}),!0}let A=!1;if(t.rejected.match(w)){const{meta:{condition:O,arg:m,requestId:u}}=w;if(O&&m.subscribe){const o=_e(T,m.queryCacheKey,st);o.set(u,m.subscriptionOptions??o.get(u)??{}),A=!0}}return A},S=()=>i.currentSubscriptions,I={getSubscriptions:S,getSubscriptionCount:T=>{const A=S().get(T);return(A==null?void 0:A.size)??0},isRequestSubscribed:(T,w)=>{var O;const A=S();return!!((O=A==null?void 0:A.get(T))!=null&&O.get(w))}};function k(T){return JSON.parse(JSON.stringify(Object.fromEntries([...T].map(([w,A])=>[w,Object.fromEntries(A)]))))}return(T,w)=>{if(b||(b=k(i.currentSubscriptions)),e.util.resetApiState.match(T))return b={},i.currentSubscriptions.clear(),y=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(T))return[!1,I];const A=v(i.currentSubscriptions,T);let O=!0;if(A){y||(y=setTimeout(()=>{const o=k(i.currentSubscriptions),[,h]=$t(b,()=>o);w.next(e.internalActions.subscriptionsUpdated(h)),b=o,y=null},500));const m=typeof T.type=="string"&&!!T.type.startsWith(p),u=t.rejected.match(T)&&T.meta.condition&&!!T.meta.arg.subscribe;O=!m&&!u}return[O,!1]}},dr=2147483647/1e3-1,fr=({reducerPath:e,api:t,queryThunk:i,context:f,internalState:p,selectors:{selectQueryEntry:b,selectConfig:y},getRunningQueryThunk:M,mwApi:R})=>{const{removeQueryResult:v,unsubscribeQueryResult:S,cacheEntriesUpserted:E}=t.internalActions,Q=ne(S.match,i.fulfilled,i.rejected,E.match);function I(m){const u=p.currentSubscriptions.get(m);return u?u.size>0:!1}const k={};function T(m){var u;for(const o of m.values())(u=o==null?void 0:o.abort)==null||u.call(o)}const w=(m,u)=>{const o=u.getState(),h=y(o);if(Q(m)){let l;if(E.match(m))l=m.payload.map(g=>g.queryDescription.queryCacheKey);else{const{queryCacheKey:g}=S.match(m)?m.payload:m.meta.arg;l=[g]}A(l,u,h)}if(t.util.resetApiState.match(m)){for(const[l,g]of Object.entries(k))g&&clearTimeout(g),delete k[l];T(p.runningQueries),T(p.runningMutations)}if(f.hasRehydrationInfo(m)){const{queries:l}=f.extractRehydrationInfo(m);A(Object.keys(l),u,h)}};function A(m,u,o){const h=u.getState();for(const l of m){const g=b(h,l);g!=null&&g.endpointName&&O(l,g.endpointName,u,o)}}function O(m,u,o,h){const l=me(f,u),g=(l==null?void 0:l.keepUnusedDataFor)??h.keepUnusedDataFor;if(g===1/0)return;const a=Math.max(0,Math.min(g,dr));if(!I(m)){const s=k[m];s&&clearTimeout(s),k[m]=setTimeout(()=>{if(!I(m)){const n=b(o.getState(),m);if(n!=null&&n.endpointName){const r=o.dispatch(M(n.endpointName,n.originalArgs));r==null||r.abort()}o.dispatch(v({queryCacheKey:m}))}delete k[m]},a*1e3)}}return w},_t=new Error("Promise never resolved before cacheEntryRemoved."),hr=({api:e,reducerPath:t,context:i,queryThunk:f,mutationThunk:p,internalState:b,selectors:{selectQueryEntry:y,selectApiState:M}})=>{const R=nt(f),v=nt(p),S=oe(f,p),E={},{removeQueryResult:Q,removeMutationResult:I,cacheEntriesUpserted:k}=e.internalActions;function T(o,h,l){const g=E[o];g!=null&&g.valueResolved&&(g.valueResolved({data:h,meta:l}),delete g.valueResolved)}function w(o){const h=E[o];h&&(delete E[o],h.cacheEntryRemoved())}function A(o){const{arg:h,requestId:l}=o.meta,{endpointName:g,originalArgs:a}=h;return[g,a,l]}const O=(o,h,l)=>{const g=m(o);function a(s,n,r,d){const c=y(l,n),P=y(h.getState(),n);!c&&P&&u(s,d,n,h,r)}if(f.pending.match(o)){const[s,n,r]=A(o);a(s,g,r,n)}else if(k.match(o))for(const{queryDescription:s,value:n}of o.payload){const{endpointName:r,originalArgs:d,queryCacheKey:c}=s;a(r,c,o.meta.requestId,d),T(c,n,{})}else if(p.pending.match(o)){if(h.getState()[t].mutations[g]){const[n,r,d]=A(o);u(n,r,g,h,d)}}else if(S(o))T(g,o.payload,o.meta.baseQueryMeta);else if(Q.match(o)||I.match(o))w(g);else if(e.util.resetApiState.match(o))for(const s of Object.keys(E))w(s)};function m(o){return R(o)?o.meta.arg.queryCacheKey:v(o)?o.meta.arg.fixedCacheKey??o.meta.requestId:Q.match(o)?o.payload.queryCacheKey:I.match(o)?Ae(o.payload):""}function u(o,h,l,g,a){const s=me(i,o),n=s==null?void 0:s.onCacheEntryAdded;if(!n)return;const r={},d=new Promise(C=>{r.cacheEntryRemoved=C}),c=Promise.race([new Promise(C=>{r.valueResolved=C}),d.then(()=>{throw _t})]);c.catch(()=>{}),E[l]=r;const P=e.endpoints[o].select(Ue(s)?h:l),D=g.dispatch((C,_,j)=>j),N={...g,getCacheEntry:()=>P(g.getState()),requestId:a,extra:D,updateCachedData:Ue(s)?C=>g.dispatch(e.util.updateQueryData(o,h,C)):void 0,cacheDataLoaded:c,cacheEntryRemoved:d},q=n(h,N);Promise.resolve(q).catch(C=>{if(C!==_t)throw C})}return O},pr=({api:e,context:{apiUid:t},reducerPath:i})=>(f,p)=>{e.util.resetApiState.match(f)&&p.dispatch(e.internalActions.middlewareRegistered(t))},gr=({reducerPath:e,context:t,context:{endpointDefinitions:i},mutationThunk:f,queryThunk:p,api:b,assertTagType:y,refetchQuery:M,internalState:R})=>{const{removeQueryResult:v}=b.internalActions,S=ne(oe(f),xe(f)),E=ne(oe(p,f),ye(p,f));let Q=[],I=0;const k=(A,O)=>{(p.pending.match(A)||f.pending.match(A))&&I++,E(A)&&(I=Math.max(0,I-1)),S(A)?w(nn(A,"invalidatesTags",i,y),O):E(A)?w([],O):b.util.invalidateTags.match(A)&&w(yt(A.payload,void 0,void 0,void 0,void 0,y),O)};function T(){return I>0}function w(A,O){const m=O.getState(),u=m[e];if(Q.push(...A),u.config.invalidationBehavior==="delayed"&&T())return;const o=Q;if(Q=[],o.length===0)return;const h=b.util.selectInvalidatedBy(m,o);t.batch(()=>{const l=Array.from(h.values());for(const{queryCacheKey:g}of l){const a=u.queries[g],s=_e(R.currentSubscriptions,g,st);a&&(s.size===0?O.dispatch(v({queryCacheKey:g})):a.status!==re&&O.dispatch(M(a)))}})}return k},yr=({reducerPath:e,queryThunk:t,api:i,refetchQuery:f,internalState:p})=>{const{currentPolls:b,currentSubscriptions:y}=p,M=new Set;let R=null;const v=(w,A)=>{(i.internalActions.updateSubscriptionOptions.match(w)||i.internalActions.unsubscribeQueryResult.match(w))&&S(w.payload.queryCacheKey,A),(t.pending.match(w)||t.rejected.match(w)&&w.meta.condition)&&S(w.meta.arg.queryCacheKey,A),(t.fulfilled.match(w)||t.rejected.match(w)&&!w.meta.condition)&&E(w.meta.arg,A),i.util.resetApiState.match(w)&&(k(),R&&(clearTimeout(R),R=null),M.clear())};function S(w,A){M.add(w),R||(R=setTimeout(()=>{for(const O of M)Q({queryCacheKey:O},A);M.clear(),R=null},0))}function E({queryCacheKey:w},A){const O=A.getState()[e],m=O.queries[w],u=y.get(w);if(!m||m.status===re)return;const{lowestPollingInterval:o,skipPollingIfUnfocused:h}=T(u);if(!Number.isFinite(o))return;const l=b.get(w);l!=null&&l.timeout&&(clearTimeout(l.timeout),l.timeout=void 0);const g=Date.now()+o;b.set(w,{nextPollTimestamp:g,pollingInterval:o,timeout:setTimeout(()=>{(O.config.focused||!h)&&A.dispatch(f(m)),E({queryCacheKey:w},A)},o)})}function Q({queryCacheKey:w},A){const m=A.getState()[e].queries[w],u=y.get(w);if(!m||m.status===re)return;const{lowestPollingInterval:o}=T(u);if(!Number.isFinite(o)){I(w);return}const h=b.get(w),l=Date.now()+o;(!h||l<h.nextPollTimestamp)&&E({queryCacheKey:w},A)}function I(w){const A=b.get(w);A!=null&&A.timeout&&clearTimeout(A.timeout),b.delete(w)}function k(){for(const w of b.keys())I(w)}function T(w=new Map){let A=!1,O=Number.POSITIVE_INFINITY;for(const m of w.values())m.pollingInterval&&(O=Math.min(m.pollingInterval,O),A=m.skipPollingIfUnfocused||A);return{lowestPollingInterval:O,skipPollingIfUnfocused:A}}return v},mr=({api:e,context:t,queryThunk:i,mutationThunk:f})=>{const p=lt(i,f),b=ye(i,f),y=oe(i,f),M={};return(v,S)=>{var E,Q;if(p(v)){const{requestId:I,arg:{endpointName:k,originalArgs:T}}=v.meta,w=me(t,k),A=w==null?void 0:w.onQueryStarted;if(A){const O={},m=new Promise((l,g)=>{O.resolve=l,O.reject=g});m.catch(()=>{}),M[I]=O;const u=e.endpoints[k].select(Ue(w)?T:I),o=S.dispatch((l,g,a)=>a),h={...S,getCacheEntry:()=>u(S.getState()),requestId:I,extra:o,updateCachedData:Ue(w)?l=>S.dispatch(e.util.updateQueryData(k,T,l)):void 0,queryFulfilled:m};A(T,h)}}else if(y(v)){const{requestId:I,baseQueryMeta:k}=v.meta;(E=M[I])==null||E.resolve({data:v.payload,meta:k}),delete M[I]}else if(b(v)){const{requestId:I,rejectedWithValue:k,baseQueryMeta:T}=v.meta;(Q=M[I])==null||Q.reject({error:v.payload??v.error,isUnhandledError:!k,meta:T}),delete M[I]}}},br=({reducerPath:e,context:t,api:i,refetchQuery:f,internalState:p})=>{const{removeQueryResult:b}=i.internalActions,y=(R,v)=>{Be.match(R)&&M(v,"refetchOnFocus"),Ve.match(R)&&M(v,"refetchOnReconnect")};function M(R,v){const S=R.getState()[e],E=S.queries,Q=p.currentSubscriptions;t.batch(()=>{for(const I of Q.keys()){const k=E[I],T=Q.get(I);if(!T||!k)continue;const w=[...T.values()];(w.some(O=>O[v]===!0)||w.every(O=>O[v]===void 0)&&S.config[v])&&(T.size===0?R.dispatch(b({queryCacheKey:I})):k.status!==re&&R.dispatch(f(k)))}})}return y};function vr(e){const{reducerPath:t,queryThunk:i,api:f,context:p,getInternalState:b}=e,{apiUid:y}=p,M={invalidateTags:ee(`${t}/invalidateTags`)},R=Q=>Q.type.startsWith(`${t}/`),v=[pr,fr,gr,yr,hr,mr];return{middleware:Q=>{let I=!1;const k=b(Q.dispatch),T={...e,internalState:k,refetchQuery:E,isThisApiSliceAction:R,mwApi:Q},w=v.map(m=>m(T)),A=lr(T),O=br(T);return m=>u=>{if(!Lt(u))return m(u);I||(I=!0,Q.dispatch(f.internalActions.middlewareRegistered(y)));const o={...Q,next:m},h=Q.getState(),[l,g]=A(u,o,h);let a;if(l?a=m(u):a=g,Q.getState()[t]&&(O(u,o,h),R(u)||p.hasRehydrationInfo(u)))for(const s of w)s(u,o,h);return a}},actions:M};function E(Q){return e.api.endpoints[Q.endpointName].initiate(Q.originalArgs,{subscribe:!1,forceRefetch:!0})}}var Ut=Symbol(),on=({createSelector:e=Bt}={})=>({name:Ut,init(t,{baseQuery:i,tagTypes:f,reducerPath:p,serializeQueryArgs:b,keepUnusedDataFor:y,refetchOnMountOrArgChange:M,refetchOnFocus:R,refetchOnReconnect:v,invalidationBehavior:S,onSchemaFailure:E,catchSchemaFailure:Q,skipSchemaValidation:I},k){pn();const T=x=>x;Object.assign(t,{reducerPath:p,endpoints:{},internalActions:{onOnline:Ve,onOffline:gt,onFocus:Be,onFocusLost:pt},util:{}});const w=ur({serializeQueryArgs:b,reducerPath:p,createSelector:e}),{selectInvalidatedBy:A,selectCachedArgsForQuery:O,buildQuerySelector:m,buildInfiniteQuerySelector:u,buildMutationSelector:o}=w;te(t.util,{selectInvalidatedBy:A,selectCachedArgsForQuery:O});const{queryThunk:h,infiniteQueryThunk:l,mutationThunk:g,patchQueryData:a,updateQueryData:s,upsertQueryData:n,prefetch:r,buildMatchThunkActions:d}=ar({baseQuery:i,reducerPath:p,context:k,api:t,serializeQueryArgs:b,assertTagType:T,selectors:w,onSchemaFailure:E,catchSchemaFailure:Q,skipSchemaValidation:I}),{reducer:c,actions:P}=cr({context:k,queryThunk:h,mutationThunk:g,serializeQueryArgs:b,reducerPath:p,assertTagType:T,config:{refetchOnFocus:R,refetchOnReconnect:v,refetchOnMountOrArgChange:M,keepUnusedDataFor:y,reducerPath:p,invalidationBehavior:S}});te(t.util,{patchQueryData:a,updateQueryData:s,upsertQueryData:n,prefetch:r,resetApiState:P.resetApiState,upsertQueryEntries:P.cacheEntriesUpserted}),te(t.internalActions,P);const D=new WeakMap,N=x=>_e(D,x,()=>({currentSubscriptions:new Map,currentPolls:new Map,runningQueries:new Map,runningMutations:new Map})),{buildInitiateQuery:q,buildInitiateInfiniteQuery:C,buildInitiateMutation:_,getRunningMutationThunk:j,getRunningMutationsThunk:$,getRunningQueriesThunk:V,getRunningQueryThunk:L}=or({queryThunk:h,mutationThunk:g,infiniteQueryThunk:l,api:t,serializeQueryArgs:b,context:k,getInternalState:N});te(t.util,{getRunningMutationThunk:j,getRunningMutationsThunk:$,getRunningQueryThunk:L,getRunningQueriesThunk:V});const{middleware:z,actions:K}=vr({reducerPath:p,context:k,queryThunk:h,mutationThunk:g,infiniteQueryThunk:l,api:t,assertTagType:T,selectors:w,getRunningQueryThunk:L,getInternalState:N});return te(t.util,K),te(t,{reducer:c,middleware:z}),{name:Ut,injectEndpoint(x,F){var B;const J=(B=t.endpoints)[x]??(B[x]={});He(F)&&te(J,{name:x,select:m(x,F),initiate:q(x,F)},d(h,x)),rr(F)&&te(J,{name:x,select:o(),initiate:_(x)},d(g,x)),ze(F)&&te(J,{name:x,select:u(x,F),initiate:C(x,F)},d(h,x))}}}});on();function je(e){return e.replace(e[0],e[0].toUpperCase())}var Sr="query",wr="mutation",Er="infinitequery";function Rr(e){return e.type===Sr}function Ir(e){return e.type===wr}function an(e){return e.type===Er}function Se(e,...t){return Object.assign(e,...t)}var Ye=Symbol();function Xe(e){const t=U.useRef(e),i=U.useMemo(()=>ft(t.current,e),[e]);return U.useEffect(()=>{t.current!==i&&(t.current=i)},[i]),i}function pe(e){const t=U.useRef(e);return U.useEffect(()=>{Ie(t.current,e)||(t.current=e)},[e]),Ie(t.current,e)?t.current:e}var Pr=()=>typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",Mr=Pr(),Ar=()=>typeof navigator<"u"&&navigator.product==="ReactNative",Cr=Ar(),Qr=()=>Mr||Cr?U.useLayoutEffect:U.useEffect,Tr=Qr(),Ft=e=>e.isUninitialized?{...e,isUninitialized:!1,isFetching:!0,isLoading:e.data===void 0,status:Kt.pending}:e;function Ze(e,...t){const i={};return t.forEach(f=>{i[f]=e[f]}),i}var et=["data","status","isLoading","isSuccess","isError","error"];function Or({api:e,moduleOptions:{batch:t,hooks:{useDispatch:i,useSelector:f,useStore:p},unstable__sideEffectsInRender:b,createSelector:y},serializeQueryArgs:M,context:R}){const v=b?h=>h():U.useEffect,S=h=>{var l,g;return(g=(l=h.current)==null?void 0:l.unsubscribe)==null?void 0:g.call(l)},E=R.endpointDefinitions;return{buildQueryHooks:m,buildInfiniteQueryHooks:u,buildMutationHook:o,usePrefetch:k};function Q(h,l,g){if(l!=null&&l.endpointName&&h.isUninitialized){const{endpointName:c}=l,P=E[c];g!==Z&&M({queryArgs:l.originalArgs,endpointDefinition:P,endpointName:c})===M({queryArgs:g,endpointDefinition:P,endpointName:c})&&(l=void 0)}let a=h.isSuccess?h.data:l==null?void 0:l.data;a===void 0&&(a=h.data);const s=a!==void 0,n=h.isLoading,r=(!l||l.isLoading||l.isUninitialized)&&!s&&n,d=h.isSuccess||s&&(n&&!(l!=null&&l.isError)||h.isUninitialized);return{...h,data:a,currentData:h.data,isFetching:n,isLoading:r,isSuccess:d}}function I(h,l,g){if(l!=null&&l.endpointName&&h.isUninitialized){const{endpointName:c}=l,P=E[c];g!==Z&&M({queryArgs:l.originalArgs,endpointDefinition:P,endpointName:c})===M({queryArgs:g,endpointDefinition:P,endpointName:c})&&(l=void 0)}let a=h.isSuccess?h.data:l==null?void 0:l.data;a===void 0&&(a=h.data);const s=a!==void 0,n=h.isLoading,r=(!l||l.isLoading||l.isUninitialized)&&!s&&n,d=h.isSuccess||n&&s;return{...h,data:a,currentData:h.data,isFetching:n,isLoading:r,isSuccess:d}}function k(h,l){const g=i(),a=pe(l);return U.useCallback((s,n)=>g(e.util.prefetch(h,s,{...a,...n})),[h,g,a])}function T(h,l,{refetchOnReconnect:g,refetchOnFocus:a,refetchOnMountOrArgChange:s,skip:n=!1,pollingInterval:r=0,skipPollingIfUnfocused:d=!1,...c}={}){const{initiate:P}=e.endpoints[h],D=i(),N=U.useRef(void 0);if(!N.current){const W=D(e.internalActions.internal_getRTKQSubscriptions());N.current=W}const q=Xe(n?Z:l),C=pe({refetchOnReconnect:g,refetchOnFocus:a,pollingInterval:r,skipPollingIfUnfocused:d}),_=c.initialPageParam,j=pe(_),$=c.refetchCachedPages,V=pe($),L=U.useRef(void 0);let{queryCacheKey:z,requestId:K}=L.current||{},x=!1;z&&K&&(x=N.current.isRequestSubscribed(z,K));const F=!x&&L.current!==void 0;return v(()=>{F&&(L.current=void 0)},[F]),v(()=>{var B;const W=L.current;if(q===Z){W==null||W.unsubscribe(),L.current=void 0;return}const J=(B=L.current)==null?void 0:B.subscriptionOptions;if(!W||W.arg!==q){W==null||W.unsubscribe();const H=D(P(q,{subscriptionOptions:C,forceRefetch:s,...an(E[h])?{initialPageParam:j,refetchCachedPages:V}:{}}));L.current=H}else C!==J&&W.updateSubscriptionOptions(C)},[D,P,s,q,C,F,j,V,h]),[L,D,P,C]}function w(h,l){return(a,{skip:s=!1,selectFromResult:n}={})=>{const{select:r}=e.endpoints[h],d=Xe(s?Z:a),c=U.useRef(void 0),P=U.useMemo(()=>y([r(d),(_,j)=>j,_=>d],l,{memoizeOptions:{resultEqualityCheck:Ie}}),[r,d]),D=U.useMemo(()=>n?y([P],n,{devModeChecks:{identityFunctionCheck:"never"}}):P,[P,n]),N=f(_=>D(_,c.current),Ie),q=p(),C=P(q.getState(),c.current);return Tr(()=>{c.current=C},[C]),N}}function A(h){U.useEffect(()=>()=>{S(h),h.current=void 0},[h])}function O(h){if(!h.current)throw new Error(Y(38));return h.current.refetch()}function m(h){const l=(s,n={})=>{const[r]=T(h,s,n);return A(r),U.useMemo(()=>({refetch:()=>O(r)}),[r])},g=({refetchOnReconnect:s,refetchOnFocus:n,pollingInterval:r=0,skipPollingIfUnfocused:d=!1}={})=>{const{initiate:c}=e.endpoints[h],P=i(),[D,N]=U.useState(Ye),q=U.useRef(void 0),C=pe({refetchOnReconnect:s,refetchOnFocus:n,pollingInterval:r,skipPollingIfUnfocused:d});v(()=>{var L,z;const V=(L=q.current)==null?void 0:L.subscriptionOptions;C!==V&&((z=q.current)==null||z.updateSubscriptionOptions(C))},[C]);const _=U.useRef(C);v(()=>{_.current=C},[C]);const j=U.useCallback(function(V,L=!1){let z;return t(()=>{S(q),q.current=z=P(c(V,{subscriptionOptions:_.current,forceRefetch:!L})),N(V)}),z},[P,c]),$=U.useCallback(()=>{var V,L;(V=q.current)!=null&&V.queryCacheKey&&P(e.internalActions.removeQueryResult({queryCacheKey:(L=q.current)==null?void 0:L.queryCacheKey}))},[P]);return U.useEffect(()=>()=>{S(q)},[]),U.useEffect(()=>{D!==Ye&&!q.current&&j(D,!0)},[D,j]),U.useMemo(()=>[j,D,{reset:$}],[j,D,$])},a=w(h,Q);return{useQueryState:a,useQuerySubscription:l,useLazyQuerySubscription:g,useLazyQuery(s){const[n,r,{reset:d}]=g(s),c=a(r,{...s,skip:r===Ye}),P=U.useMemo(()=>({lastArg:r}),[r]);return U.useMemo(()=>[n,{...c,reset:d},P],[n,c,d,P])},useQuery(s,n){const r=l(s,n),d=a(s,{selectFromResult:s===Z||n!=null&&n.skip?void 0:Ft,...n}),c=Ze(d,...et);return U.useDebugValue(c),U.useMemo(()=>({...d,...r}),[d,r])}}}function u(h){const l=(a,s={})=>{const[n,r,d,c]=T(h,a,s),P=U.useRef(c);v(()=>{P.current=c},[c]);const D=s.refetchCachedPages,N=pe(D),q=U.useCallback(function(j,$){let V;return t(()=>{S(n),n.current=V=r(d(j,{subscriptionOptions:P.current,direction:$}))}),V},[n,r,d]);A(n);const C=Xe(s.skip?Z:a),_=U.useCallback(j=>{if(!n.current)throw new Error(Y(38));const $={refetchCachedPages:(j==null?void 0:j.refetchCachedPages)??N};return n.current.refetch($)},[n,N]);return U.useMemo(()=>({trigger:q,refetch:_,fetchNextPage:()=>q(C,"forward"),fetchPreviousPage:()=>q(C,"backward")}),[_,q,C])},g=w(h,I);return{useInfiniteQueryState:g,useInfiniteQuerySubscription:l,useInfiniteQuery(a,s){const{refetch:n,fetchNextPage:r,fetchPreviousPage:d}=l(a,s),c=g(a,{selectFromResult:a===Z||s!=null&&s.skip?void 0:Ft,...s}),P=Ze(c,...et,"hasNextPage","hasPreviousPage");return U.useDebugValue(P),U.useMemo(()=>({...c,fetchNextPage:r,fetchPreviousPage:d,refetch:n}),[c,r,d,n])}}}function o(h){return({selectFromResult:l,fixedCacheKey:g}={})=>{const{select:a,initiate:s}=e.endpoints[h],n=i(),[r,d]=U.useState();U.useEffect(()=>()=>{r!=null&&r.arg.fixedCacheKey||r==null||r.reset()},[r]);const c=U.useCallback(function(V){const L=n(s(V,{fixedCacheKey:g}));return d(L),L},[n,s,g]),{requestId:P}=r||{},D=U.useMemo(()=>a({fixedCacheKey:g,requestId:r==null?void 0:r.requestId}),[g,r,a]),N=U.useMemo(()=>l?y([D],l):D,[l,D]),q=f(N,Ie),C=g==null?r==null?void 0:r.arg.originalArgs:void 0,_=U.useCallback(()=>{t(()=>{r&&d(void 0),g&&n(e.internalActions.removeMutationResult({requestId:P,fixedCacheKey:g}))})},[n,g,r,P]),j=Ze(q,...et,"endpointName");U.useDebugValue(j);const $=U.useMemo(()=>({...q,originalArgs:C,reset:_}),[q,C,_]);return U.useMemo(()=>[c,$],[c,$])}}}var qr=Symbol(),Dr=({batch:e=Sn,hooks:t={useDispatch:Rn,useSelector:En,useStore:wn},createSelector:i=Bt,unstable__sideEffectsInRender:f=!1,...p}={})=>({name:qr,init(b,{serializeQueryArgs:y},M){const R=b,{buildQueryHooks:v,buildInfiniteQueryHooks:S,buildMutationHook:E,usePrefetch:Q}=Or({api:b,moduleOptions:{batch:e,hooks:t,unstable__sideEffectsInRender:f,createSelector:i},serializeQueryArgs:y,context:M});return Se(R,{usePrefetch:Q}),Se(M,{batch:e}),{injectEndpoint(I,k){if(Rr(k)){const{useQuery:T,useLazyQuery:w,useLazyQuerySubscription:A,useQueryState:O,useQuerySubscription:m}=v(I);Se(R.endpoints[I],{useQuery:T,useLazyQuery:w,useLazyQuerySubscription:A,useQueryState:O,useQuerySubscription:m}),b[`use${je(I)}Query`]=T,b[`useLazy${je(I)}Query`]=w}if(Ir(k)){const T=E(I);Se(R.endpoints[I],{useMutation:T}),b[`use${je(I)}Mutation`]=T}else if(an(k)){const{useInfiniteQuery:T,useInfiniteQuerySubscription:w,useInfiniteQueryState:A}=S(I);Se(R.endpoints[I],{useInfiniteQuery:T,useInfiniteQuerySubscription:w,useInfiniteQueryState:A}),b[`use${je(I)}InfiniteQuery`]=T}}}}}),Hr=sn(on(),Dr());export{Hr as a,$r as b,fe as c,Br as f,Vr as s};
